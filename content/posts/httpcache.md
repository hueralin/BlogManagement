---
title: "浏览器缓存策略"
date: 2019-10-09T20:00:01+08:00
draft: false
---

我再也不废话了......切入正题!  

缓存是干啥的也不用咱说了,浏览器缓存即基于HTTP头的缓存.  

浏览器缓存策略有两种:强缓存和协商缓存.  

先大体说一下浏览器缓存的过程:  

1. 浏览器向服务器发起请求前首先向浏览器缓存查询是否有该请求的结果及缓存标识.  
2. 有,则从缓存中读取(强缓存成功),否则再去询问服务器(协商缓存 or 直接请求).

### 强缓存策略  

**强缓存的三种情况:**  

1. 请求前先去询问浏览器缓存,若有缓存且未失效,则直接从浏览器缓存读取结果,此被称之为"强缓存成功".  
2. "强缓存失败", 若有缓存,但已失效,则执行**"协商缓存"策略.**  
3. "强缓存失败", 若无缓存, 则向服务器正式发起请求.

强缓存策略涉及到的HTTP头部: **Cache-Control / expires**  

expires 是 HTTP/1.0 的产物,它的值是一个绝对值,即缓存失效的时间.浏览器会拿客户端的时间和缓存中的此标识做对比,来判断缓存是否过期.所以它的缺陷比较明显,因为客户端和服务器的时间并不总是同步的,也就是说可能出现误差.(可能影响并不多大,别喷我......)  

Cache-Control 是 HTTP/1.1 的产物,它的值就丰富多了:  

1. **public**   所有内容都将被缓存(客户端和代理服务器都可以)  
2. **private**  默认值,只有客户端才能缓存  
3. **no-cache** 只有客户端缓存,但是否使用缓存需要经过协商缓存来确定  
4. **no-store** 所有内容都不缓存  
5. **max-age=xxx**  缓存将于xxx秒后失效

我们一般使用第五种方式  

可以看到cache-control使用的是相对时间,弥补了expires的时间误差缺陷. 在实际应用过程中这两种方式都会有,但是cache-control的优先级要高一些.

### 协商缓存策略  

协商缓存发生在有缓存但到期的情况下. 实际上, 服务器设置的过期时间是用来表明此时的缓存可能会过期, 但我不能保证, 届时你得向我确认一下, 所以, 缓存并不一定失效了. 和商品的保质期一个道理.  

此时, 我们需要向服务器发起请求, 询问这个缓存能不能用, 如果服务器表示能用, 返回304, 那我们就去缓存中读取, 否则我们再向服务器请求新的数据.  

协商缓存策略涉及到的HTTP头部: **Last-Modified / If-Modified-Since 以及 Etag / If-None-Match**   

**Last-Modified / If-Modified-Since** 是 HTTP/1.1 的产物, last-modified 标识的是资源的最后修改时间, 协商缓存开始时会发请求, 将last-modified的值赋给 请求头 if-modified-since, 向服务器发起询问 "这个资源在这个时间后修改了么?" 如果没有修改, 则返回304, 浏览器就会从缓存中读取数据, 否则会请求新的数据, 并更新缓存. 

**Etag / If-None-Match** 也是 HTTP/1.1 的产物, 过程和上面一样, 只不过Etag是由服务器根据资源内容生成的唯一标识, 具有唯一性. 用资源的最后修改时间作为标识的话不太准确, 因为可能会在1秒内多次修改文件的情况. 

Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高.  

### 缓存的位置  

浏览器缓存的位置一般有两个: 硬盘缓存(disk cache) 和 内存缓存(memory cache), 我们打开F12, 可在network选项卡中网络请求的size列查看.  
内存缓存会将编译解析后的文件存放在当前标签页进程的内存中, 读取速度较快.  

硬盘缓存则是将资源放入硬盘中, 需要进行对硬盘文件做I/O操作, 速度较慢.  

存在内存中的缓存文件, 会在刷新页面后被直接读取, 如果关闭了该标签页, 再次打开页面会重新请求. 而在硬盘中的缓存文件不会这样.

浏览器对不同类型的文件选取不同的存储位置, 像JS, img等会被放进内存缓存, 而CSS会被放进硬盘缓存.

### 总结  

强缓存的优先级高于协商缓存, 强缓存失效才会进行协商缓存. 强缓存失效不代表缓存过期, 只是不确定其是否真的过期, 所以需要协商缓存过程来确认一下.

桥豆麻袋! 不够细, 还有些没深入......
